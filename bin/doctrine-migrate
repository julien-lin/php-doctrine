#!/usr/bin/env php
<?php

/**
 * Script CLI pour g√©rer les migrations Doctrine
 * 
 * Ce script cherche automatiquement la configuration de la base de donn√©es
 * dans les emplacements standards ou peut utiliser une variable d'environnement.
 * 
 * Usage:
 *   php bin/doctrine-migrate generate [EntityClass]  # G√©n√®re une migration
 *   php bin/doctrine-migrate migrate                  # Ex√©cute les migrations en attente
 *   php bin/doctrine-migrate status                  # Affiche le statut
 * 
 * Configuration:
 *   Le script cherche la config dans (dans cet ordre):
 *   1. Variable d'environnement DOCTRINE_CONFIG (chemin vers fichier PHP)
 *   2. config/database.php (depuis le r√©pertoire courant)
 *   3. ../config/database.php (depuis le r√©pertoire courant)
 *   4. Variables d'environnement DB_* (DB_HOST, DB_NAME, DB_USER, DB_PASSWORD)
 */

// Trouver le r√©pertoire du package
$packageDir = __DIR__;
$autoloadPath = $packageDir . '/../vendor/autoload.php';

// Si on est dans vendor, utiliser l'autoload du package parent
if (!file_exists($autoloadPath)) {
    // Chercher depuis le r√©pertoire courant (application)
    $currentDir = getcwd();
    $autoloadPath = $currentDir . '/vendor/autoload.php';
    
    if (!file_exists($autoloadPath)) {
        echo "‚ùå Erreur : Impossible de trouver vendor/autoload.php\n";
        echo "Assurez-vous d'ex√©cuter ce script depuis le r√©pertoire racine de votre projet.\n";
        exit(1);
    }
}

require_once $autoloadPath;

use JulienLinard\Doctrine\EntityManager;

// Charger la configuration
$config = loadDatabaseConfig();

if ($config === null) {
    echo "‚ùå Erreur : Impossible de charger la configuration de la base de donn√©es.\n";
    echo "\nLe script cherche la configuration dans:\n";
    echo "  1. Variable d'environnement DOCTRINE_CONFIG (chemin vers fichier PHP)\n";
    echo "  2. config/database.php\n";
    echo "  3. ../config/database.php\n";
    echo "  4. Variables d'environnement DB_HOST, DB_NAME, DB_USER, DB_PASSWORD\n";
    echo "\nCr√©ez un fichier config/database.php avec:\n";
    echo "<?php\n";
    echo "return [\n";
    echo "    'driver' => 'mysql',\n";
    echo "    'host' => 'localhost',\n";
    echo "    'dbname' => 'mydatabase',\n";
    echo "    'user' => 'root',\n";
    echo "    'password' => 'password'\n";
    echo "];\n";
    exit(1);
}

// Cr√©er EntityManager
try {
    $em = new EntityManager($config);
} catch (\Exception $e) {
    echo "‚ùå Erreur de connexion : {$e->getMessage()}\n";
    exit(1);
}

// R√©cup√©rer l'action depuis les arguments CLI
$action = $argv[1] ?? 'status';
$entityClass = $argv[2] ?? null;

// R√©cup√©rer les options (pour --steps)
$options = [];
for ($i = 2; $i < $argc; $i++) {
    if (strpos($argv[$i], '--steps=') === 0) {
        $options['steps'] = (int)substr($argv[$i], 8);
    }
}

try {
    match ($action) {
        'generate' => generateMigration($em, $entityClass),
        'migrate' => executeMigrations($em),
        'rollback' => rollbackMigrations($em, $options['steps'] ?? null),
        'status' => showStatus($em),
        'help' => showHelp(),
        default => throw new \InvalidArgumentException(
            "Action inconnue : {$action}. Utilisez 'generate', 'migrate', 'rollback', 'status' ou 'help'"
        )
    };
} catch (\Exception $e) {
    echo "‚ùå Erreur : {$e->getMessage()}\n";
    exit(1);
}

/**
 * D√©tecte si une requ√™te SQL est une commande DDL
 * 
 * @param string $sql Requ√™te SQL √† analyser
 * @return bool True si c'est une commande DDL
 */
function isDDLStatement(string $sql): bool
{
    $sql = trim($sql);
    $ddlKeywords = ['CREATE', 'DROP', 'ALTER', 'TRUNCATE', 'RENAME'];
    
    foreach ($ddlKeywords as $keyword) {
        if (stripos($sql, $keyword) === 0) {
            return true;
        }
    }
    
    return false;
}

/**
 * Charge la configuration de la base de donn√©es
 */
function loadDatabaseConfig(): ?array
{
    // 1. Variable d'environnement DOCTRINE_CONFIG
    if (($configPath = getenv('DOCTRINE_CONFIG')) && file_exists($configPath)) {
        $config = require $configPath;
        if (is_array($config)) {
            return $config;
        }
    }
    
    // 2. config/database.php depuis le r√©pertoire courant
    $currentDir = getcwd();
    $configPath = $currentDir . '/config/database.php';
    if (file_exists($configPath)) {
        $config = require $configPath;
        if (is_array($config)) {
            return $config;
        }
    }
    
    // 3. ../config/database.php depuis le r√©pertoire courant
    $configPath = $currentDir . '/../config/database.php';
    if (file_exists($configPath)) {
        $config = require $configPath;
        if (is_array($config)) {
            return $config;
        }
    }
    
    // 4. Variables d'environnement DB_*
    $dbHost = getenv('DB_HOST');
    $dbName = getenv('DB_NAME') ?: getenv('DB_DATABASE');
    $dbUser = getenv('DB_USER') ?: getenv('DB_USERNAME');
    $dbPassword = getenv('DB_PASSWORD') ?: getenv('DB_PASS');
    
    if ($dbHost && $dbName && $dbUser) {
        return [
            'driver' => getenv('DB_DRIVER') ?: 'mysql',
            'host' => $dbHost,
            'port' => getenv('DB_PORT') ?: null,
            'dbname' => $dbName,
            'user' => $dbUser,
            'password' => $dbPassword ?: '',
            'charset' => getenv('DB_CHARSET') ?: 'utf8mb4',
        ];
    }
    
    return null;
}

/**
 * G√©n√®re une migration pour une ou plusieurs entit√©s
 */
function generateMigration(EntityManager $em, ?string $entityClass): void
{
    echo "üîç G√©n√©ration de la migration...\n\n";
    
    if ($entityClass) {
        // Migration pour une seule entit√©
        if (!class_exists($entityClass)) {
            throw new \RuntimeException("La classe {$entityClass} n'existe pas.");
        }
        
        $sql = $em->generateMigration($entityClass);
        
        if (empty($sql)) {
            echo "‚úÖ Aucune migration n√©cessaire pour {$entityClass}.\n";
            return;
        }
        
        echo "üìÑ Migration SQL pour {$entityClass} :\n";
        echo str_repeat("=", 60) . "\n";
        echo $sql . "\n";
        echo str_repeat("=", 60) . "\n";
        
        // Proposer de sauvegarder
        $manager = $em->getMigrationManager();
        $migrationName = $manager->generateMigrationName();
        $migrationsPath = getcwd() . '/migrations';
        
        if (!is_dir($migrationsPath)) {
            mkdir($migrationsPath, 0755, true);
        }
        
        $filename = $migrationsPath . '/' . $migrationName . '.sql';
        file_put_contents($filename, $sql);
        
        echo "\nüíæ Migration sauvegard√©e dans : {$filename}\n";
    } else {
        // Migration pour toutes les entit√©s dans src/Entity ou App/Entity
        $entitiesPath = findEntitiesPath();
        $entityClasses = scanEntities($entitiesPath);
        
        if (empty($entityClasses)) {
            echo "‚ö†Ô∏è  Aucune entit√© trouv√©e.\n";
            echo "Cherch√© dans : {$entitiesPath}\n";
            echo "\nVous pouvez sp√©cifier une entit√© :\n";
            echo "  php bin/doctrine-migrate generate App\\Entity\\User\n";
            return;
        }
        
        echo "üìã Entit√©s trouv√©es : " . implode(', ', $entityClasses) . "\n\n";
        
        $sql = $em->generateMigrations($entityClasses);
        
        if (empty($sql)) {
            echo "‚úÖ Aucune migration n√©cessaire. La base de donn√©es est √† jour.\n";
            return;
        }
        
        echo "üìÑ Migration SQL g√©n√©r√©e :\n";
        echo str_repeat("=", 60) . "\n";
        echo $sql . "\n";
        echo str_repeat("=", 60) . "\n";
        
        // Sauvegarder dans un fichier
        $manager = $em->getMigrationManager();
        $migrationName = $manager->generateMigrationName();
        $migrationsPath = getcwd() . '/migrations';
        
        if (!is_dir($migrationsPath)) {
            mkdir($migrationsPath, 0755, true);
        }
        
        $filename = $migrationsPath . '/' . $migrationName . '.sql';
        file_put_contents($filename, $sql);
        
        echo "\nüíæ Migration sauvegard√©e dans : {$filename}\n";
    }
}

/**
 * Ex√©cute les migrations en attente
 */
function executeMigrations(EntityManager $em): void
{
    echo "üîç Recherche des migrations...\n\n";
    
    $migrationsPath = getcwd() . '/migrations';
    
    if (!is_dir($migrationsPath)) {
        echo "‚ö†Ô∏è  Le dossier migrations n'existe pas. Cr√©ation...\n";
        mkdir($migrationsPath, 0755, true);
    }
    
    $files = glob($migrationsPath . '/*.sql');
    
    if (empty($files)) {
        echo "‚úÖ Aucune migration trouv√©e.\n";
        return;
    }
    
    // Trier les migrations par nom (chronologique)
    sort($files);
    
    $manager = $em->getMigrationManager();
    $runner = $em->getMigrationRunner();
    $executed = $manager->getExecutedMigrations();
    
    $pending = [];
    foreach ($files as $file) {
        $migrationName = basename($file, '.sql');
        if (!in_array($migrationName, $executed)) {
            $pending[] = ['name' => $migrationName, 'file' => $file];
        }
    }
    
    if (empty($pending)) {
        echo "‚úÖ Toutes les migrations sont d√©j√† appliqu√©es.\n";
        return;
    }
    
    echo "üìã Migrations en attente : " . count($pending) . "\n\n";
    
    foreach ($pending as $migration) {
        echo "‚ñ∂Ô∏è  Ex√©cution de {$migration['name']}...\n";
        
        $sql = file_get_contents($migration['file']);
        
        if (empty(trim($sql))) {
            echo "‚ö†Ô∏è  Migration vide, ignor√©e.\n\n";
            continue;
        }
        
        try {
            // D√©tecter automatiquement les DDL et d√©sactiver les transactions
            $useTransaction = !isDDLStatement(trim($sql));
            
            if (!$useTransaction) {
                echo "üí° DDL d√©tect√©, transaction d√©sactiv√©e.\n";
            }
            
            $runner->run($sql, $useTransaction);
            $manager->markAsExecuted($migration['name']);
            echo "‚úÖ Migration {$migration['name']} appliqu√©e avec succ√®s.\n\n";
        } catch (\Exception $e) {
            echo "‚ùå Erreur lors de l'ex√©cution de {$migration['name']} : {$e->getMessage()}\n";
            exit(1);
        }
    }
    
    echo "‚úÖ Toutes les migrations ont √©t√© appliqu√©es.\n";
}

/**
 * Annule les migrations (rollback)
 */
function rollbackMigrations(EntityManager $em, ?int $steps = null): void
{
    echo "üîÑ Rollback des migrations...\n\n";
    
    $manager = $em->getMigrationManager();
    $runner = $em->getMigrationRunner();
    
    // R√©cup√©rer les migrations √† annuler
    $migrationsToRollback = $manager->getMigrationsToRollback($steps);
    
    if (empty($migrationsToRollback)) {
        echo "‚úÖ Aucune migration √† annuler.\n";
        return;
    }
    
    $count = count($migrationsToRollback);
    if ($steps !== null) {
        echo "üìã Annulation de {$count} migration(s)...\n\n";
    } else {
        echo "üìã Annulation de la derni√®re migration...\n\n";
    }
    
    $migrationsPath = getcwd() . '/migrations';
    
    foreach ($migrationsToRollback as $migrationName) {
        echo "‚è™ Annulation de {$migrationName}...\n";
        
        // Chercher le fichier de migration
        $migrationFile = $migrationsPath . '/' . $migrationName . '.sql';
        
        if (!file_exists($migrationFile)) {
            // Essayer de charger une classe de migration
            $migrationClass = loadMigrationClass($migrationName);
            
            if ($migrationClass === null) {
                echo "‚ö†Ô∏è  Fichier de migration non trouv√© : {$migrationFile}\n";
                echo "   Tentative de rollback automatique...\n";
                
                // Rollback automatique bas√© sur le nom de la migration
                $rollbackSql = generateAutomaticRollback($migrationName, $em);
                
                if (empty($rollbackSql)) {
                    echo "‚ùå Impossible de g√©n√©rer un rollback automatique pour {$migrationName}\n";
                    echo "   Cr√©ez un fichier {$migrationName}_down.sql ou une classe MigrationInterface\n";
                    continue;
                }
                
                try {
                    $useTransaction = !isDDLStatement(trim($rollbackSql));
                    $runner->rollback($rollbackSql, $useTransaction);
                    $manager->markAsRolledBack($migrationName);
                    echo "‚úÖ Migration {$migrationName} annul√©e avec succ√®s.\n\n";
                } catch (\Exception $e) {
                    echo "‚ùå Erreur lors du rollback de {$migrationName} : {$e->getMessage()}\n";
                    exit(1);
                }
                
                continue;
            }
            
            // Utiliser la classe de migration
            if ($migrationClass instanceof \JulienLinard\Doctrine\Migration\MigrationInterface) {
                $rollbackSql = $migrationClass->down();
                
                try {
                    $useTransaction = !isDDLStatement(trim($rollbackSql));
                    $runner->rollback($rollbackSql, $useTransaction);
                    $manager->markAsRolledBack($migrationName);
                    echo "‚úÖ Migration {$migrationName} annul√©e avec succ√®s.\n\n";
                } catch (\Exception $e) {
                    echo "‚ùå Erreur lors du rollback de {$migrationName} : {$e->getMessage()}\n";
                    exit(1);
                }
                
                continue;
            }
        }
        
        // Chercher un fichier _down.sql
        $downFile = $migrationsPath . '/' . $migrationName . '_down.sql';
        
        if (file_exists($downFile)) {
            $rollbackSql = file_get_contents($downFile);
        } else {
            // Rollback automatique bas√© sur le contenu du fichier up
            $upSql = file_get_contents($migrationFile);
            $rollbackSql = generateAutomaticRollback($migrationName, $em, $upSql);
            
            if (empty($rollbackSql)) {
                echo "‚ùå Impossible de g√©n√©rer un rollback automatique pour {$migrationName}\n";
                echo "   Cr√©ez un fichier {$migrationName}_down.sql\n";
                continue;
            }
        }
        
        if (empty(trim($rollbackSql))) {
            echo "‚ö†Ô∏è  Rollback vide, ignor√©.\n\n";
            continue;
        }
        
        try {
            // D√©tecter automatiquement les DDL et d√©sactiver les transactions
            $useTransaction = !isDDLStatement(trim($rollbackSql));
            
            if (!$useTransaction) {
                echo "üí° DDL d√©tect√©, transaction d√©sactiv√©e.\n";
            }
            
            $runner->rollback($rollbackSql, $useTransaction);
            $manager->markAsRolledBack($migrationName);
            echo "‚úÖ Migration {$migrationName} annul√©e avec succ√®s.\n\n";
        } catch (\Exception $e) {
            echo "‚ùå Erreur lors du rollback de {$migrationName} : {$e->getMessage()}\n";
            exit(1);
        }
    }
    
    echo "‚úÖ Rollback termin√©.\n";
}

/**
 * Charge une classe de migration
 */
function loadMigrationClass(string $migrationName): ?object
{
    $migrationsPath = getcwd() . '/migrations';
    $classFile = $migrationsPath . '/' . $migrationName . '.php';
    
    if (!file_exists($classFile)) {
        return null;
    }
    
    require_once $classFile;
    
    // Chercher la classe dans le namespace
    $className = $migrationName;
    if (class_exists($className)) {
        return new $className();
    }
    
    // Chercher dans le namespace App\Migrations
    $className = 'App\\Migrations\\' . $migrationName;
    if (class_exists($className)) {
        return new $className();
    }
    
    return null;
}

/**
 * G√©n√®re un rollback automatique bas√© sur le nom ou le SQL de la migration
 */
function generateAutomaticRollback(string $migrationName, EntityManager $em, ?string $upSql = null): string
{
    // Si on a le SQL up, essayer de g√©n√©rer le rollback inverse
    if ($upSql !== null) {
        // D√©tecter CREATE TABLE -> DROP TABLE
        if (preg_match('/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?`?(\w+)`?/i', $upSql, $matches)) {
            $tableName = $matches[1];
            return "DROP TABLE IF EXISTS `{$tableName}`;";
        }
        
        // D√©tecter ALTER TABLE ADD COLUMN -> ALTER TABLE DROP COLUMN
        if (preg_match('/ALTER\s+TABLE\s+`?(\w+)`?\s+ADD\s+COLUMN\s+`?(\w+)`?/i', $upSql, $matches)) {
            $tableName = $matches[1];
            $columnName = $matches[2];
            return "ALTER TABLE `{$tableName}` DROP COLUMN `{$columnName}`;";
        }
    }
    
    // Bas√© sur le nom de la migration
    if (preg_match('/Create(\w+)Table/i', $migrationName, $matches)) {
        $tableName = strtolower($matches[1]);
        return "DROP TABLE IF EXISTS `{$tableName}`;";
    }
    
    return '';
}

/**
 * Affiche le statut des migrations
 */
function showStatus(EntityManager $em): void
{
    echo "üìä Statut des migrations\n";
    echo str_repeat("=", 60) . "\n\n";
    
    $migrationsPath = getcwd() . '/migrations';
    $files = glob($migrationsPath . '/*.sql');
    $manager = $em->getMigrationManager();
    $executed = $manager->getExecutedMigrations();
    
    if (empty($files)) {
        echo "Aucune migration trouv√©e dans {$migrationsPath}\n";
        return;
    }
    
    foreach ($files as $file) {
        $migrationName = basename($file, '.sql');
        $isExecuted = in_array($migrationName, $executed);
        $status = $isExecuted ? '‚úÖ Appliqu√©e' : '‚è≥ En attente';
        
        if ($isExecuted) {
            $applied++;
        } else {
            $pending++;
        }
        
        echo "{$migrationName} : {$status}\n";
    }
    
    echo "\n";
    echo "Total : " . count($files) . " migration(s)\n";
    echo "Appliqu√©es : {$applied}\n";
    echo "En attente : {$pending}\n";
}

/**
 * Trouve le chemin vers les entit√©s
 */
function findEntitiesPath(): string
{
    $currentDir = getcwd();
    $possiblePaths = [
        $currentDir . '/src/Entity',
        $currentDir . '/app/Entity',
        $currentDir . '/App/Entity',
        $currentDir . '/../src/Entity',
        $currentDir . '/../app/Entity',
    ];
    
    foreach ($possiblePaths as $path) {
        if (is_dir($path)) {
            return $path;
        }
    }
    
    return $currentDir . '/src/Entity'; // Par d√©faut
}

/**
 * Scanne le dossier des entit√©s pour trouver toutes les classes
 */
function scanEntities(string $entitiesPath): array
{
    if (!is_dir($entitiesPath)) {
        return [];
    }
    
    $entities = [];
    $files = glob($entitiesPath . '/*.php');
    
    foreach ($files as $file) {
        $className = getClassNameFromFile($file);
        if ($className && isEntity($className)) {
            $entities[] = $className;
        }
    }
    
    return $entities;
}

/**
 * Extrait le nom de classe depuis un fichier
 */
function getClassNameFromFile(string $file): ?string
{
    $content = file_get_contents($file);
    
    if (preg_match('/namespace\s+([^;]+);/', $content, $namespaceMatches)) {
        if (preg_match('/class\s+(\w+)/', $content, $classMatches)) {
            return $namespaceMatches[1] . '\\' . $classMatches[1];
        }
    }
    
    return null;
}

/**
 * V√©rifie si une classe est une entit√© Doctrine
 */
function isEntity(string $className): bool
{
    try {
        $reflection = new \ReflectionClass($className);
        $attributes = $reflection->getAttributes(\JulienLinard\Doctrine\Mapping\Entity::class);
        return !empty($attributes);
    } catch (\Exception $e) {
        return false;
    }
}

/**
 * Affiche l'aide
 */
function showHelp(): void
{
    echo "üìñ Doctrine Migrations CLI\n";
    echo str_repeat("=", 60) . "\n\n";
    echo "Usage:\n";
    echo "  php bin/doctrine-migrate [command] [options]\n\n";
    echo "Commandes disponibles:\n";
    echo "  generate [EntityClass]  G√©n√®re une migration pour une entit√© ou toutes les entit√©s\n";
    echo "  migrate                Ex√©cute les migrations en attente\n";
    echo "  rollback [--steps=N]   Annule les migrations (derni√®re par d√©faut, ou N migrations)\n";
    echo "  status                 Affiche le statut des migrations\n";
    echo "  help                   Affiche cette aide\n\n";
    echo "Exemples:\n";
    echo "  php bin/doctrine-migrate generate\n";
    echo "  php bin/doctrine-migrate generate App\\Entity\\User\n";
    echo "  php bin/doctrine-migrate migrate\n";
    echo "  php bin/doctrine-migrate rollback\n";
    echo "  php bin/doctrine-migrate rollback --steps=3\n";
    echo "  php bin/doctrine-migrate status\n\n";
    echo "Configuration:\n";
    echo "  Le script cherche la config dans:\n";
    echo "  1. Variable d'environnement DOCTRINE_CONFIG\n";
    echo "  2. config/database.php\n";
    echo "  3. Variables d'environnement DB_*\n";
}

